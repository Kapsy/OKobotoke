
    // could use MotionEvent.Obtain for copying events
    // and dispatchTouchEvent(event) for playing back
    // listarray is faster though
    @Override
    public boolean onTouchEvent(MotionEvent event) {
    	    	    	
    	PlainTouchCirc ct1 = this.circtouchfirst[this.getCurcirctouchfirst()];
    	PlainTouchCirc ct2 = this.circtouchsecond[this.getCurcirctouchsecond()];
    	
    	NormalLineFader fdr = this.faderline[this.getCurfaderline()]; 
    	
    	AccelTouch at1 = this.acceltouchfirst[this.getCuracceltouchfirst()];
    	AccelTouch at2 = this.acceltouchsecond[this.getCuracceltouchsecond()];
    	
		int pts = event.getPointerCount();
		framerec.setTouchpts(pts);

    	float x0 = event.getX(0);
		float y0 = event.getY(0);
		
   		float x1 = 0F;
		float y1 = 0F;
		
		if (pts == 2) {
			x1 = event.getX(1);
			y1 = event.getY(1);
		}
    	
    	int index = event.getActionIndex();
    	    	//Log.v("MotionEvent", "event.getActionIndex() " + event.getActionIndex());
	 			 
			switch (event.getAction() & MotionEvent.ACTION_MASK) {

			case MotionEvent.ACTION_DOWN:
				//Log.v("MotionEvent", "ACTION_DOWN");

				// why is this here?
				this.touchenabled = true;
				
				// automatically starts recording if touched while playing
				if (this.framerec.isPlayingback()
						|| !this.framerec.isRecordingnow()) {

//					Log.v("MotionEvent", "this.framerec.isPlayingback() " + this.framerec.isPlayingback());
//					Log.v("MotionEvent", "this.framerec.isRecordingnow() " + this.framerec.isRecordingnow());
					
					this.releaseAllTouchAnims();
//					Log.v("MotionEvent", "releaseAllTouchAnims() called");
					
					ct1 = this.circtouchfirst[this.getCurcirctouchfirst()];
			    	ct2 = this.circtouchsecond[this.getCurcirctouchsecond()];
			    	fdr = this.faderline[this.getCurfaderline()]; 
			    	
			    	at1 = this.acceltouchfirst[this.getCuracceltouchfirst()];
			    	at2 = this.acceltouchsecond[this.getCuracceltouchsecond()];
			    				    	
					this.framerec.startRecord();
					this.recbar.init();
				}

				ct1.setPosX(x0);
				ct1.setPosY(y0);
				ct1.init();
				
				at1.setTargetpoint1(ct1);
				at1.init();
				
				framerec.setMotionevent(MotionEvent.ACTION_DOWN);

				break;

			case MotionEvent.ACTION_POINTER_DOWN:
				//    	        	Log.v("MotionEvent", "ACTION_POINTER_DOWN");
				
				if (this.touchenabled && this.secondtouchenabled) {
					if (ct1.getRelAnim() == false) {
		
						ct2.setPosX(x1);
						ct2.setPosY(y1);
						ct2.init();
						ct2.setARGB(0, 0, 255, 255);
						
						
						at2.setTargetpoint1(ct2);
						at2.init();
						
						
						fdr.setSnagpoint1(at1);
						fdr.setSnagpoint2(at2);
						fdr.init();
						
						this.disableonrel = true;
						
						framerec.setMotionevent(MotionEvent.ACTION_POINTER_DOWN);

					}
					
				}
				else {
					this.disableonrel = false;
					
				}
				
				
				break;

			case MotionEvent.ACTION_MOVE:
//				Log.v("MotionEvent", "ACTION_MOVE");

				if (this.touchenabled) {
					
//					Log.v("MotionEvent", "touchenabled " + touchenabled);
					
					if (ct1.getRelAnim() == false) {
						
						ct1.setPosX(x0);
						ct1.setPosY(y0);
						
						//this.sendSingleTouchVals(x0, y0);
						this.sendSingleTouchVals(this.acceltouchfirst[this.getCuracceltouchfirst()].getPosX(),
								this.acceltouchfirst[this.getCuracceltouchfirst()].getPosY());
						

						framerec.setMotionevent(MotionEvent.ACTION_MOVE);

						if (pts == MULTI_TOUCH_MAX && this.secondtouchenabled) {

							ct2.setPosX(x1);
							ct2.setPosY(y1);
							OkobotokeActivity.sendFloat("fm_index",
									OkobotokeActivity.calcToRangeFM(
											fdr.calcDistance(),
											screendiag));
						
						}
					}
				}
				break;

			case MotionEvent.ACTION_POINTER_UP:
				// Log.v("MotionEvent", "ACTION_POINTER_UP");

				if (this.touchenabled) {
					if (index == 1 && this.secondtouchenabled) {

						OkobotokeActivity.sendFloat("fm_index", 12F);
						
						ct2.relAnimOn();
						fdr.relAnimOn();
						this.nextCirctouchsecond();
						this.nextFaderline();
						
						at2.relAnimOn();
						this.nextAcceltouchsecond();
						
						
						if (this.disableonrel) {
							this.secondtouchenabled = false;
						}
						

						framerec.setMotionevent(MotionEvent.ACTION_POINTER_UP);

					}
					if (index == 0) {
						this.releaseAllTouchAnims();
						framerec.setMotionevent(MotionEvent.ACTION_POINTER_UP);
					}
				}
				break;

			case MotionEvent.ACTION_UP:
				// Log.v("MotionEvent", "ACTION_UP");

				if (index == 0) {
	
					// dont understand why i did this... revise
					if (this.touchenabled) {
						ct1.relAnimOn();
						this.nextCirctouchfirst();
						
						at1.relAnimOn();
						this.nextAcceltouchfirst();
	
						framerec.setMotionevent(MotionEvent.ACTION_UP);
						framerec.setTouchpts(0);
					} else {
						this.touchenabled = false;
					}
				}
	
				break;

			}
			// 指三本処理
			if (pts > MULTI_TOUCH_MAX) {
				this.releaseAllTouchAnims();
			}

			
			
			
			

			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		return true;
    }
